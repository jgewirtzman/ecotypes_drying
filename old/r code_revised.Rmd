

```{r j max}
# Load the A/Ci data
aci <- read_csv(file.path(wd, "CSVs and R Code", "A_Ci Ouputs_Corrected.csv"))

# Calculate average Jmax and Vcmax per Tag
aci_avg_dat <- aci %>%
  group_by(Tag, Population, `Treatment Name`) %>%
    dplyr::summarize(
    jmax_avg = mean(Jmax, na.rm = TRUE),
    vcmax_avg = mean(Vcmax, na.rm = TRUE),
    .groups = "drop"
  )

# View the resulting data frame
print(aci_avg_dat)
```
```{r d13c}

# Load the d13C data
d13c <- read_csv(file.path(wd, "CSVs and R Code", "Ecotypes2017_Drying_d13C.csv"))

# Rename the Tag column if needed
names(d13c)[5] <- "Tag"

# Calculate average d13C per Tag
d13c_avg_dat <- d13c %>%
  group_by(Tag, Population, `Treatment Name`) %>%
    dplyr::summarize(
    d13c_avg = mean(d13C, na.rm = TRUE),
    .groups = "drop"
  )

# View the resulting data frame
print(d13c_avg_dat)

```

```{r merge}

# List of all datasets to merge
datasets <- list(
  gwc_dat, ndvi_dat, lai_dat, pheno_dat, amax_avg_dat, wpot_avg_dat, aci_avg_dat, d13c_avg_dat
)

# Merge all datasets using reduce() and left_join()
all_data <- purrr::reduce(datasets, left_join, by = c("Tag", "Population", "Treatment Name"))

write.csv(all_data,
  paste(
    "all_data_merged",
    Sys.time(),
    ".csv",
    sep=""
  ))
```


```{r gwc}
# Load necessary packages

# Print the predicted GWC values
#plot(soilgwc$predicted_gwc~soilgwc$GWC)

# Relevel and relabel factors
soilgwc <- soilgwc %>%
  mutate(
    Population = factor(Population, levels = c("SG", "TL", "CF"), labels = c("Sagwon", "Toolik", "Coldfoot")),
    `Treatment Name` = factor(`Treatment Name`, levels = c("Wet", "Dry", "Deep"))
  )


# Fit mixed model and summarize
lmm_gwc <- lmer(GWC ~ `Treatment Name` * Population + (1 | Tag), data = soilgwc)

# Display model summary
cat("Mixed Model Summary:\n")
summary(lmm_gwc)

# Perform ANOVA on the mixed model
cat("\nANOVA Table:\n")
anova_lmm <- anova(lmm_gwc)
print(anova_lmm)

# Compute estimated marginal means (EMMs) and display
cat("\nEstimated Marginal Means (EMMs):\n")
gwc_emm <- emmeans(lmm_gwc, ~ `Treatment Name` | Population)
summary(gwc_emm)

# Pairwise contrasts for EMMs
cat("\nPairwise Contrasts:\n")
contrast_output <- contrast(gwc_emm, interaction = "pairwise")
print(contrast_output)

# Fit mixed model with lmerTest for p-values
lmm_gwc <- lmer(GWC ~ `Treatment Name` * Population + (1 | Tag), data = soilgwc)

# Summary with p-values for fixed effects
summary(lmm_gwc)
anova(lmm_gwc)

# Convert EMMs to a data frame for plotting
emm_df <- as.data.frame(gwc_emm)

# Interaction plot
interaction_plot <- ggplot(emm_df, aes(x = `Treatment Name`, y = emmean, color = Population, group = Population)) +
  geom_point(size = 3) + geom_line(size = 1) +
  geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), width = 0.2) +
  labs(title = "Interaction Plot: GWC by Treatment and Population", x = "Treatment", y = "Estimated GWC (EMMeans)") +
  theme_minimal() + theme(legend.position = "top")

interaction_plot

# Bar plot of EMMs
bar_plot <- ggplot(emm_df, aes(x = Population, y = emmean, fill = `Treatment Name`)) +
  geom_bar(stat = "identity", position = position_dodge(0.9), color = "black") +
  geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), width = 0.2, position = position_dodge(0.9)) +
  labs(title = "Bar Plot of GWC (EMMeans) by Treatment and Population", x = "Population", y = "Estimated GWC (EMMeans)") +
  scale_fill_manual(values = c("Wet" = "#1f77b4", "Dry" = "#8c564b", "Deep" = "#d62728")) +
  theme_minimal() + theme(legend.position = "top")

bar_plot

# Raw means and SE
raw_means <- soilgwc %>%
  group_by(Population, `Treatment Name`) %>%
  summarize(mean_gwc = mean(GWC, na.rm = TRUE) * 100, se_gwc = sd(GWC, na.rm = TRUE) / sqrt(n()) * 100, .groups = "drop")

raw_means

treatment_means <- soilgwc %>%
  group_by(`Treatment Name`) %>%
  summarize(
    mean_gwc = mean(GWC, na.rm = TRUE) * 100,
    se_gwc = sd(GWC, na.rm = TRUE) / sqrt(n()) * 100
  )
treatment_means


# Time series plot
ts_plot <- ggplot(soilgwc, aes(x = DOY, y = GWC * 100, color = `Treatment Name`)) +
  geom_line(aes(group = Tag), alpha = 0.3, size = 0.5) +
  stat_summary(fun = mean, geom = "line", size = 1.5) +
  stat_summary(fun.data = mean_cl_boot, geom = "ribbon", aes(fill = `Treatment Name`), color = NA, alpha = 0.3) +
  scale_color_manual(values = c("Wet" = "#1f77b4", "Dry" = "#8c564b", "Deep" = "#d62728"), name = "Treatment") +
  scale_fill_manual(values = c("Wet" = "#1f77b4", "Dry" = "#8c564b", "Deep" = "#d62728"), guide = "none") +
  labs(x = "Day of Year", y = "GWC (%)") +
  theme_classic() +
  facet_wrap(~ Population, ncol = 1)

# Bar plot for raw means
bar_plot_raw <- ggplot(raw_means, aes(x = `Treatment Name`, y = mean_gwc, fill = `Treatment Name`)) +
  geom_bar(stat = "identity", position = position_dodge(), alpha = 0.8) +
  geom_errorbar(aes(ymin = mean_gwc - se_gwc, ymax = mean_gwc + se_gwc), width = 0.2) +
  scale_fill_manual(values = c("Wet" = "#1f77b4", "Dry" = "#8c564b", "Deep" = "#d62728"), guide = "none") +
  labs(y = "Mean GWC (%)", x = "Treatment") +
  facet_wrap(~ Population, ncol = 1) +
  theme_classic() +
  theme(legend.position = "none")

# Combine plots with shared legend
combined_plot <- ts_plot + bar_plot_raw + 
  plot_layout(ncol = 2, widths = c(2, 1)) &
  theme(legend.position = "top")

# Display combined plot
print(combined_plot)
```




```{r productivity}

# Merge NDVI and GWC AUC datasets by common identifiers
ndvi_gwc_merged <- left_join(ndvi_dat, gwc_dat, by = c("Population", "Treatment Name", "Tag"))

# Update population names and order
ndvi_gwc_merged$Population <- factor(ndvi_gwc_merged$Population,
                                     levels = c("SG", "TL", "CF"),
                                     labels = c("Sagwon", "Toolik", "Coldfoot"))

# Standardize GWC AUC and NDVI AUC to z-scores
ndvi_gwc_merged$gwc_auc_z <- scale(ndvi_gwc_merged$gwc_auc)
ndvi_gwc_merged$ndvi_auc_z <- scale(ndvi_gwc_merged$ndvi_auc)


# Custom colors for the updated population names
custom_colors <- c("Coldfoot" = "#3E6347",  
                   "Toolik" = "#90C49B", 
                   "Sagwon" = "#79A9C8")  

# Plot with standardized variables
ggplot(ndvi_gwc_merged, aes(y = ndvi_auc_z, x = gwc_auc_z, color = Population, fill=Population)) +
  # Points with black borders
  geom_point(size = 3.5, shape = 21, stroke = 1.2, alpha=0.7) +
  # Lines with black borders
  geom_smooth(method = "lm", size = 1.5, 
              se = TRUE, fullrange=TRUE, alpha = 0.2) +
  scale_color_manual(values = custom_colors) +
  scale_fill_manual(values = custom_colors) +
  theme_classic() +
  labs(x = "Growing Season Soil Moisture\n(GWC AUC Z-Score)",
       y = "Cumulative Vegetation Greenness\n(NDVI AUC Z-Score)",
       color = "Population",
       fill = "Population") +
  theme(legend.position = "top",
        text = element_text(size = 14),
        axis.text = element_text(size = 12),
        axis.title = element_text(size = 14))+
  guides(color = guide_legend(title = "Population"))


anova(lm(data=ndvi_gwc_merged, ndvi_auc~gwc_auc*Population*`Treatment Name`))
summary(lm(data=ndvi_gwc_merged, ndvi_auc~gwc_auc))


```


```{r model checks}
# -----------------------------
# Updated Mixed-Effects Models with Quadratic DOY Term and Cross-Validation
# -----------------------------

# Rename `Treatment Name` to `Treatment_Name` to fix space issue
rename_columns <- function(data) {
  colnames(data) <- gsub("Treatment Name", "Treatment_Name", colnames(data))
  return(data)
}

lai_data<-ndvi_data

# Apply the renaming to all datasets
ndvi_data <- rename_columns(ndvi_data)
lai_data <- rename_columns(lai_data)
pheno1 <- rename_columns(pheno1)

# Function to fit a quadratic mixed-effects model using poly(DOY, 2)
fit_quadratic_model <- function(data, response_var) {
  formula <- as.formula(paste(response_var, "~ poly(DOY, 2) * Treatment_Name * Population + (1 | Tag)"))
  model <- lmer(formula, data = data)
  return(model)
}

# Function to fit a linear mixed-effects model
fit_linear_model <- function(data, response_var) {
  formula <- as.formula(paste(response_var, "~ DOY * Treatment_Name * Population + (1 | Tag)"))
  model <- lmer(formula, data = data)
  return(model)
}

# Fit linear and quadratic models for LAI, NDVI, and tot_gl
lai_linear <- fit_linear_model(ndvi_data, "LAI")
lai_quadratic <- fit_quadratic_model(ndvi_data, "LAI")
ndvi_linear <- fit_linear_model(ndvi_data, "NDVI")
ndvi_quadratic <- fit_quadratic_model(ndvi_data, "NDVI")
tot_gl_linear <- fit_linear_model(pheno1, "TillerTotalGreenLength")
tot_gl_quadratic <- fit_quadratic_model(pheno1, "TillerTotalGreenLength")

# -----------------------------
# Generate Predictions from Quadratic Models
# -----------------------------

# Function to add model predictions to the data
add_predictions <- function(data, model, response_var) {
  data <- data %>%
    mutate(predicted = predict(model, newdata = data))
  return(data)
}

# Add predictions to the datasets
ndvi_data <- add_predictions(ndvi_data, ndvi_quadratic, "NDVI")
lai_data <- add_predictions(ndvi_data, lai_quadratic, "LAI")
pheno1 <- add_predictions(pheno1, tot_gl_quadratic, "TillerTotalGreenLength")

# -----------------------------
# Visualization: Time-Series Plots with Model Predictions
# -----------------------------
plot_time_series_predictions <- function(data, y_var, y_label) {
  ggplot(data, aes(x = DOY, y = !!sym(y_var), color = Treatment_Name, group = interaction(Tag, Treatment_Name))) +
    geom_point(alpha = 0.4, size = 2) +
    geom_line(aes(y = predicted), size = 1.2) +
    scale_color_manual(values = c("Wet" = "#1f77b4", "Dry" = "#8c564b", "Deep" = "#d62728")) +
    labs(x = "Day of Year", y = y_label, color = "Treatment") +
    theme_classic() +
    facet_wrap(~ Population, ncol = 1) +
    theme(
      legend.position = "top",
      plot.title = element_text(face = "bold", hjust = 0.5, size = 16),
      axis.text = element_text(size = 12),
      axis.title = element_text(size = 14),
      strip.text = element_text(size = 14),
      legend.text = element_text(size = 12)
    )
}

# Generate and display the updated plots with model predictions
lai_time_series_predictions <- plot_time_series_predictions(lai_data, "LAI", "Leaf Area Index (Model Predictions)")
ndvi_time_series_predictions <- plot_time_series_predictions(ndvi_data, "NDVI", "NDVI (Model Predictions)")
tot_gl_time_series_predictions <- plot_time_series_predictions(pheno1, "TillerTotalGreenLength", "Total Green Length (Model Predictions)")

# Print the plots
print(lai_time_series_predictions)
print(ndvi_time_series_predictions)
print(tot_gl_time_series_predictions)

# -----------------------------
# Cross-Validation Function
# -----------------------------
cv_mixed_model <- function(formula, data, folds = 10) {
  set.seed(123)
  data$folds <- sample(rep(1:folds, length.out = nrow(data)))
  mse_list <- vector("numeric", length = folds)
  
  for (i in 1:folds) {
    train_data <- data[data$folds != i, ]
    test_data <- data[data$folds == i, ]
    model <- lmer(formula, data = train_data)
    predictions <- predict(model, newdata = test_data, allow.new.levels = TRUE)
    mse_list[i] <- mean((test_data$NDVI - predictions)^2)
  }
  
  return(mean(mse_list))
}

# Run cross-validation for linear and quadratic NDVI models
cv_ndvi_linear_mse <- cv_mixed_model(NDVI ~ DOY * Treatment_Name * Population + (1 | Tag), ndvi_data)
cv_ndvi_quadratic_mse <- cv_mixed_model(NDVI ~ poly(DOY, 2) * Treatment_Name * Population + (1 | Tag), ndvi_data)

# Print cross-validation results
print(paste("NDVI Linear Model MSE:", round(cv_ndvi_linear_mse, 3)))
print(paste("NDVI Quadratic Model MSE:", round(cv_ndvi_quadratic_mse, 3)))

# -----------------------------
# AIC and BIC Comparison
# -----------------------------
aic_bic_comparison <- data.frame(
  Model = c("NDVI Linear", "NDVI Quadratic", "LAI Linear", "LAI Quadratic", "Total Green Length Linear", "Total Green Length Quadratic"),
  AIC = c(AIC(ndvi_linear), AIC(ndvi_quadratic), AIC(lai_linear), AIC(lai_quadratic), AIC(tot_gl_linear), AIC(tot_gl_quadratic)),
  BIC = c(BIC(ndvi_linear), BIC(ndvi_quadratic), BIC(lai_linear), BIC(lai_quadratic), BIC(tot_gl_linear), BIC(tot_gl_quadratic))
)

print(aic_bic_comparison)

# -----------------------------
# Residuals Plot for Quadratic Models
# -----------------------------
par(mfrow = c(1, 3))
plot(resid(ndvi_quadratic), main = "Residuals for NDVI Quadratic Model")
plot(resid(lai_quadratic), main = "Residuals for LAI Quadratic Model")
plot(resid(tot_gl_quadratic), main = "Residuals for Total Green Length Quadratic Model")
par(mfrow = c(1, 1))

# -----------------------------
# ANOVA and Compact Letter Display (CLD) Results
# -----------------------------
anova_cld_results <- function(model, response_var) {
  cat("\nANOVA Results for", response_var, ":\n")
  print(anova(model))
  emm <- emmeans(model, ~ Population * Treatment_Name)
  cat("\nCompact Letter Display (CLD) for", response_var, ":\n")
  cld <- multcomp::cld(emm, Letters = letters)
  print(cld)
  return(cld)
}

lai_cld <- anova_cld_results(lai_quadratic, "LAI")
ndvi_cld <- anova_cld_results(ndvi_quadratic, "NDVI")
tot_gl_cld <- anova_cld_results(tot_gl_quadratic, "Total Green Length")
```

```{r lai models}
# Load necessary libraries

# Assuming `ndvi_data` is your dataset
# Fit Linear and Quadratic Mixed Models for NDVI
ndvi_linear <- lmer(NDVI ~ DOY * Treatment * Population + (1 | Tag), data = ndvi_data)
ndvi_quadratic <- lmer(NDVI ~ poly(DOY, 2) * Treatment * Population + (1 | Tag), data = ndvi_data)

# Fit Linear and Quadratic Mixed Models for LAI
lai_linear <- lmer(LAI ~ DOY * Treatment * Population + (1 | Tag), data = ndvi_data)
lai_quadratic <- lmer(LAI ~ poly(DOY, 2) * Treatment * Population + (1 | Tag), data = ndvi_data)

# Fit Linear and Quadratic Mixed Models for Biomass
biomass_linear <- lmer(Biomass ~ DOY * Treatment * Population + (1 | Tag), data = ndvi_data)
biomass_quadratic <- lmer(Biomass ~ poly(DOY, 2) * Treatment * Population + (1 | Tag), data = ndvi_data)

# Function to generate fixed effects and ANOVA summaries
summarize_models <- function(linear_model, quadratic_model, response_var) {
  cat("\n\n===========", response_var, "Model Summary ==========\n")
  
  # Fixed effects summaries
  cat("\n--- Fixed Effects (Quadratic Model) ---\n")
  fixed_effects <- tidy(quadratic_model, effects = "fixed")
  print(fixed_effects)
  
  # ANOVA table
  cat("\n--- ANOVA Table ---\n")
  anova_table <- anova(linear_model, quadratic_model)
  print(anova_table)
  
  # Return fixed effects as a dataframe for further analysis
  return(fixed_effects)
}

# Summarize each model
ndvi_summary <- summarize_models(ndvi_linear, ndvi_quadratic, "NDVI")
lai_summary <- summarize_models(lai_linear, lai_quadratic, "LAI")
biomass_summary <- summarize_models(biomass_linear, biomass_quadratic, "Biomass")

# Combine all fixed effects into a single table for comparison
fixed_effects_summary <- bind_rows(
  ndvi_summary %>% mutate(Metric = "NDVI"),
  lai_summary %>% mutate(Metric = "LAI"),
  biomass_summary %>% mutate(Metric = "Biomass")
)

# Print fixed effects summary
cat("\n--- Fixed Effects Summary for All Metrics ---\n")
print(fixed_effects_summary)

# Create a polished table using gt
fixed_effects_summary %>%
  select(Metric, term, estimate, std.error, df, statistic, p.value) %>%
  arrange(Metric, term) %>%
  gt() %>%
  tab_header(title = "Fixed Effects Summary for Phenology Models") %>%
  fmt_number(columns = c(estimate, std.error, statistic, p.value), decimals = 3)

# Compare AIC and BIC for linear and quadratic models
aic_bic_comparison <- data.frame(
  Model = c("NDVI Linear", "NDVI Quadratic", "LAI Linear", "LAI Quadratic", "Biomass Linear", "Biomass Quadratic"),
  AIC = c(AIC(ndvi_linear), AIC(ndvi_quadratic), AIC(lai_linear), AIC(lai_quadratic), AIC(biomass_linear), AIC(biomass_quadratic)),
  BIC = c(BIC(ndvi_linear), BIC(ndvi_quadratic), BIC(lai_linear), BIC(lai_quadratic), BIC(biomass_linear), BIC(biomass_quadratic))
)

print(aic_bic_comparison)


# Check random effects variance
summary(ndvi_quadratic)$varcor
summary(lai_quadratic)$varcor
summary(biomass_quadratic)$varcor

anova(ndvi_quadratic)
anova(lai_quadratic)
anova(biomass_quadratic)




# Define cross-validation function
cv_mixed_model <- function(formula, data, folds = 10) {
  set.seed(123)
  
  # Create folds
  data$folds <- sample(rep(1:folds, length.out = nrow(data)))
  
  mse_list <- vector("numeric", length = folds)
  
  for (i in 1:folds) {
    # Split data into training and testing sets
    train_data <- data[data$folds != i, ]
    test_data <- data[data$folds == i, ]
    
    # Fit the model on training data
    model <- lmer(formula, data = train_data)
    
    # Predict on testing data
    predictions <- predict(model, newdata = test_data, allow.new.levels = TRUE)
    
    # Calculate MSE for this fold
    mse_list[i] <- mean((test_data$NDVI - predictions)^2)
  }
  
  # Return the average MSE across all folds
  mean(mse_list)
}

# Run cross-validation for NDVI models
cv_ndvi_linear_mse <- cv_mixed_model(NDVI ~ DOY * Treatment * Population + (1 | Tag), ndvi_data)
cv_ndvi_quadratic_mse <- cv_mixed_model(NDVI ~ poly(DOY, 2) * Treatment * Population + (1 | Tag), ndvi_data)

# Print MSE results
print(paste("NDVI Linear Model MSE:", round(cv_ndvi_linear_mse, 3)))
print(paste("NDVI Quadratic Model MSE:", round(cv_ndvi_quadratic_mse, 3)))
```
